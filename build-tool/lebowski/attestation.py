"""
Build Attestation - Universal format for publishing build results

A build attestation is a compact, human-readable statement that proves:
- What was built (source + version)
- How it was built (opinion + toolchain)
- What was produced (output hash)

Can be posted to any platform: Twitter, Mastodon, GitHub, Slack, email, etc.
"""

import json
import hashlib
from pathlib import Path
from typing import Dict, Any, Optional
from datetime import datetime


class BuildAttestation:
    """Generate and verify build attestations"""

    def __init__(self, manifest: Dict[str, Any]):
        self.manifest = manifest
        # Extract project name from opinion metadata (no default)
        self.project_name = manifest.get('opinion', {}).get('project_name')

    def generate_compact(self) -> str:
        """Generate compact attestation (fits in a tweet)"""
        src = self.manifest.get('source', {})
        opinion = self.manifest.get('opinion', {})
        toolchain = self.manifest.get('toolchain', {})
        output = self.manifest.get('output', {})

        # Short hashes (first 12 chars)
        src_hash = src.get('dsc_sha256', 'unknown')[:12]
        opinion_hash = opinion.get('file_sha256', 'unknown')[:12]
        compiler_hash = toolchain.get('compiler_sha256', 'unknown')[:12]
        output_hash = output.get('package_sha256', 'unknown')[:12]

        header = f"🔨 {self.project_name} Build" if self.project_name else "🔨 Unknown project Build"
        return f"""{header}

📦 {src.get('package', 'unknown')}-{src.get('version', 'unknown')}
🔧 Opinion: {opinion.get('name', 'unknown')}
⚙️  Compiler: {toolchain.get('compiler', 'unknown')}
🏗️  Output: {output_hash}

Source: {src_hash}
Opinion: {opinion_hash}
Toolchain: {compiler_hash}

Rebuild & verify: lebowski verify <url>
"""

    def generate_full(self, manifest_url: Optional[str] = None) -> str:
        """Generate full attestation with all details"""
        src = self.manifest.get('source', {})
        opinion = self.manifest.get('opinion', {})
        toolchain = self.manifest.get('toolchain', {})
        output = self.manifest.get('output', {})
        env = self.manifest.get('environment', {})

        # Center the project name in the header (54 chars width)
        if self.project_name:
            project_title = f"{self.project_name.upper()} BUILD ATTESTATION"
        else:
            project_title = "UNKNOWN PROJECT BUILD ATTESTATION"
        padding = (54 - len(project_title)) // 2
        centered_title = " " * padding + project_title

        attestation = f"""╔══════════════════════════════════════════════════════╗
║{centered_title.ljust(54)}║
╚══════════════════════════════════════════════════════╝

📦 PACKAGE
   Name:    {src.get('package', 'unknown')}
   Version: {src.get('version', 'unknown')}
   Source:  {src.get('fetch_method', 'unknown')}

🔐 SOURCE HASH
   .dsc:    {src.get('dsc_sha256', 'unknown')}

🔧 OPINION
   Name:    {opinion.get('name', 'unknown')}
   Purity:  {opinion.get('purity_level', 'unknown')}
   Hash:    {opinion.get('file_sha256', 'unknown')}

⚙️  TOOLCHAIN
   Compiler: {toolchain.get('compiler', 'unknown')}
   Version:  {toolchain.get('compiler_version', 'unknown')}
   Hash:     {toolchain.get('compiler_sha256', 'unknown')}

🏗️  BUILD ENVIRONMENT
   SOURCE_DATE_EPOCH: {env.get('SOURCE_DATE_EPOCH', 'unknown')}
   CC:                {env.get('CC', 'unknown')}
   CFLAGS:            {env.get('DEB_CFLAGS_APPEND', 'none')}
   LDFLAGS:           {env.get('DEB_LDFLAGS_APPEND', 'none')}

📄 OUTPUT
   File:    {output.get('package_file', 'unknown')}
   SHA256:  {output.get('package_sha256', 'unknown')}

"""
        if manifest_url:
            attestation += f"""📋 MANIFEST
   URL: {manifest_url}

"""

        footer_name = self.project_name if self.project_name else "Unknown project"
        attestation += f"""✅ VERIFICATION
   Anyone can rebuild this package and verify the hash matches.

   Command:
   $ lebowski verify <manifest-url>

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Generated by {footer_name} - Reproducible Debian Package Builder
https://github.com/yourusername/lebowski
"""
        return attestation

    def generate_oneline(self) -> str:
        """Generate one-line attestation (for logs/commits)"""
        src = self.manifest.get('source', {})
        opinion = self.manifest.get('opinion', {})
        toolchain = self.manifest.get('toolchain', {})
        output = self.manifest.get('output', {})

        pkg = src.get('package', 'unknown')
        ver = src.get('version', 'unknown')
        opinion_name = opinion.get('name', 'unknown')
        compiler = toolchain.get('compiler', 'unknown').split('/')[-1]  # Just filename
        out_hash = output.get('package_sha256', 'unknown')[:16]

        return f"[lebowski] {pkg}-{ver} + {opinion_name} + {compiler} → {out_hash}"

    def generate_json(self) -> str:
        """Generate JSON attestation (for machine parsing)"""
        return json.dumps({
            'format': 'lebowski-attestation-v1',
            'timestamp': self.manifest.get('build_timestamp_iso'),
            'package': {
                'name': self.manifest['source']['package'],
                'version': self.manifest['source']['version'],
                'source_hash': self.manifest['source'].get('dsc_sha256'),
            },
            'opinion': {
                'name': self.manifest['opinion']['name'],
                'purity': self.manifest['opinion']['purity_level'],
                'hash': self.manifest['opinion'].get('file_sha256'),
            },
            'toolchain': {
                'compiler': self.manifest['toolchain']['compiler'],
                'version': self.manifest['toolchain'].get('compiler_version'),
                'hash': self.manifest['toolchain'].get('compiler_sha256'),
            },
            'output': {
                'filename': self.manifest['output']['package_file'],
                'hash': self.manifest['output']['package_sha256'],
            },
            'environment': self.manifest.get('environment', {}),
        }, indent=2)

    def generate_twitter(self, manifest_url: Optional[str] = None) -> str:
        """Generate Twitter-optimized attestation (280 chars)"""
        src = self.manifest.get('source', {})
        output = self.manifest.get('output', {})
        opinion = self.manifest.get('opinion', {})

        pkg = src.get('package', 'unknown')
        ver = src.get('version', 'unknown')
        out_hash = output.get('package_sha256', 'unknown')[:12]
        opinion_name = opinion.get('name', 'unknown')

        tweet = f"🔨 Built {pkg} {ver}\n"
        tweet += f"Opinion: {opinion_name}\n"
        tweet += f"Hash: {out_hash}\n"

        if manifest_url:
            tweet += f"Verify: {manifest_url}\n"

        tweet += "#reproducibleBuilds"

        return tweet

    def generate_mastodon(self, manifest_url: Optional[str] = None) -> str:
        """Generate Mastodon-optimized attestation (500 chars)"""
        src = self.manifest.get('source', {})
        output = self.manifest.get('output', {})
        opinion = self.manifest.get('opinion', {})
        toolchain = self.manifest.get('toolchain', {})

        pkg = src.get('package', 'unknown')
        ver = src.get('version', 'unknown')
        out_hash = output.get('package_sha256', 'unknown')[:16]
        opinion_name = opinion.get('name', 'unknown')
        purity = opinion.get('purity_level', 'unknown')
        compiler = toolchain.get('compiler', 'unknown').split('/')[-1]

        toot = f"""🔨 Reproducible Build Complete!

📦 Package: {pkg} {ver}
🔧 Opinion: {opinion_name} ({purity})
⚙️  Compiler: {compiler}
🔐 Output Hash: {out_hash}...

✅ Anyone can rebuild and verify!
"""

        if manifest_url:
            toot += f"\n📋 Manifest: {manifest_url}"

        toot += "\n\n#ReproducibleBuilds #SoftwareSupplyChain #Security"

        return toot

    def generate_github_markdown(self, manifest_url: Optional[str] = None) -> str:
        """Generate GitHub-flavored markdown attestation"""
        src = self.manifest.get('source', {})
        opinion = self.manifest.get('opinion', {})
        toolchain = self.manifest.get('toolchain', {})
        output = self.manifest.get('output', {})

        md = f"""## Build Attestation

**Package:** `{src.get('package')}-{src.get('version')}`

### Source
- **Fetch Method:** `{src.get('fetch_method')}`
- **DSC Hash:** `{src.get('dsc_sha256')}`

### Opinion
- **Name:** `{opinion.get('name')}`
- **Purity Level:** `{opinion.get('purity_level')}`
- **Opinion Hash:** `{opinion.get('file_sha256')}`

### Toolchain
- **Compiler:** `{toolchain.get('compiler')}`
- **Version:** `{toolchain.get('compiler_version')}`
- **Compiler Hash:** `{toolchain.get('compiler_sha256')}`

### Output
- **Filename:** `{output.get('package_file')}`
- **SHA256:** `{output.get('package_sha256')}`

"""

        if manifest_url:
            md += f"### Manifest\n{manifest_url}\n\n"

        md += """### Verification
Anyone can rebuild this package and verify it produces an identical hash:

```bash
lebowski verify """ + (manifest_url or "<manifest-url>") + """
```

This build is **reproducible** - anyone with the same source, opinion, and toolchain will produce a bit-for-bit identical package.
"""

        return md

    def generate_slack(self) -> str:
        """Generate Slack-optimized attestation"""
        src = self.manifest.get('source', {})
        output = self.manifest.get('output', {})
        opinion = self.manifest.get('opinion', {})

        return f"""*Build Complete* :hammer:

*Package:* `{src.get('package')}-{src.get('version')}`
*Opinion:* `{opinion.get('name')}`
*Output Hash:* `{output.get('package_sha256', 'unknown')[:16]}...`

:white_check_mark: Reproducible build - anyone can verify!
"""

    def hash_self(self) -> str:
        """Generate hash of attestation for signing"""
        # Create canonical JSON representation
        canonical = self.generate_json()
        return hashlib.sha256(canonical.encode()).hexdigest()


def generate_attestation(manifest_path: Path, format: str = 'full',
                        manifest_url: Optional[str] = None) -> str:
    """
    Generate build attestation from manifest file

    Args:
        manifest_path: Path to .lebowski-manifest.json
        format: Output format (compact, full, oneline, json, twitter, mastodon, github, slack)
        manifest_url: Optional URL where manifest is hosted

    Returns:
        Formatted attestation string
    """
    with open(manifest_path, 'r') as f:
        manifest = json.load(f)

    attestation = BuildAttestation(manifest)

    formats = {
        'compact': attestation.generate_compact,
        'full': lambda: attestation.generate_full(manifest_url),
        'oneline': attestation.generate_oneline,
        'json': attestation.generate_json,
        'twitter': lambda: attestation.generate_twitter(manifest_url),
        'mastodon': lambda: attestation.generate_mastodon(manifest_url),
        'github': lambda: attestation.generate_github_markdown(manifest_url),
        'slack': attestation.generate_slack,
    }

    if format not in formats:
        raise ValueError(f"Unknown format: {format}. Choose from: {', '.join(formats.keys())}")

    return formats[format]()
